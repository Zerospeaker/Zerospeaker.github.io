<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;计算机启动的总体流程&quot;&gt;&lt;a href=&quot;#计算机启动的总体流程&quot; class=&quot;headerlink&quot; title=&quot;计算机启动的总体流程&quot;&gt;&lt;/a&gt;计算机启动的总体流程&lt;/h1&gt;&lt;p&gt;在一台装有操作系统的典型Intel x86机器上，当你按下计算机启动电源的那一刻，主板、CPU、内存等硬件开始供电，这时，ROM中的BIOS完成硬件自检，然后将引导加载器从磁盘载入内存。引导加载器对CPU的控制寄存器做了一些设置工作后，就将操作系统代码从磁盘载入内存，随后将控制权交给操作系统的入口代码。操作系统的入口代码完成操作系统的各模块的初始化后，计算机就算启动完毕了。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>从XV6看操作系统启动、引导加载器 | Hickey</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.2"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-time">2022-05-11</div> </div></div><div class="container post-header"><p class="post-title" align="center">从XV6看操作系统启动、引导加载器</p></div><hr class="_title_line"><div class="container post-toc"><details class="toc" open><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%9A%84%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">计算机启动的总体流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BIOS%E5%81%9A%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88"><span class="toc-number">2.</span> <span class="toc-text">BIOS做了些什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">引导加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%A4%87"><span class="toc-number">3.1.</span> <span class="toc-text">预备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%90%AFA20-Gate"><span class="toc-number">3.2.</span> <span class="toc-text">开启A20 Gate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">进入保护模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5bootmain"><span class="toc-number">3.4.</span> <span class="toc-text">进入bootmain</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">3.5.</span> <span class="toc-text">错误处理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E6%9C%80%E7%BB%88%E7%9A%84%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%BB%A3%E7%A0%81"><span class="toc-number">4.</span> <span class="toc-text">产生最终的引导加载器代码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol></details></div><blockquote> <p>本文使用CC BY-NC-SA 4.0协议。禁止商业转载，非商业转载请注明作者和出处。</p></blockquote><div class="container post-content"><h1 id="计算机启动的总体流程"><a href="#计算机启动的总体流程" class="headerlink" title="计算机启动的总体流程"></a>计算机启动的总体流程</h1><p>在一台装有操作系统的典型Intel x86机器上，当你按下计算机启动电源的那一刻，主板、CPU、内存等硬件开始供电，这时，ROM中的BIOS完成硬件自检，然后将引导加载器从磁盘载入内存。引导加载器对CPU的控制寄存器做了一些设置工作后，就将操作系统代码从磁盘载入内存，随后将控制权交给操作系统的入口代码。操作系统的入口代码完成操作系统的各模块的初始化后，计算机就算启动完毕了。</p>
<h1 id="BIOS做了些什么"><a href="#BIOS做了些什么" class="headerlink" title="BIOS做了些什么"></a>BIOS做了些什么</h1><p>BIOS是计算机加电后执行的第一段代码，他被固化在只读存储器ROM中，BIOS主要完成以下工作：</p>
<ul>
<li>硬件自检：检测计算机的各种硬件信息，并确保他们正常工作。</li>
<li>将位于磁盘扇区0的512字节的引导加载器代码装入到内存的0x7c00位置处。</li>
</ul>
<p>完成以上工作后，BIOS的任务就结束了，接下来执行引导加载器的代码。</p>
<h1 id="引导加载器"><a href="#引导加载器" class="headerlink" title="引导加载器"></a>引导加载器</h1><p>xv6的引导加载器代码由汇编代码bootasm.S和C语言bootmain.c组成：</p>
<p><strong>bootasm.S</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;asm.h&quot;</span><br><span class="line">#include &quot;memlayout.h&quot;</span><br><span class="line">#include &quot;mmu.h&quot;</span><br><span class="line"></span><br><span class="line"># Start the first CPU: switch to 32-bit protected mode, jump into C.</span><br><span class="line"># The BIOS loads this code from the first sector of the hard disk into</span><br><span class="line"># memory at physical address 0x7c00 and starts executing in real mode</span><br><span class="line"># with %cs=0 %ip=7c00.</span><br><span class="line"></span><br><span class="line">.code16                       # Assemble for 16-bit mode</span><br><span class="line">.globl start</span><br><span class="line">start: 						  # 链接程序时会指定程序代码段地址为0x7c00，所以start在内存中的地址是0x7c00</span><br><span class="line">  cli                         # BIOS enabled interrupts; disable</span><br><span class="line"></span><br><span class="line">  # Zero data segment registers DS, ES, and SS.</span><br><span class="line">  xorw    %ax,%ax             # Set %ax to zero</span><br><span class="line">  movw    %ax,%ds             # -&gt; Data Segment</span><br><span class="line">  movw    %ax,%es             # -&gt; Extra Segment</span><br><span class="line">  movw    %ax,%ss             # -&gt; Stack Segment</span><br><span class="line"></span><br><span class="line">  # Physical address line A20 is tied to zero so that the first PCs </span><br><span class="line">  # with 2 MB would run software that assumed 1 MB.  Undo that.</span><br><span class="line">seta20.1:</span><br><span class="line">  inb     $0x64,%al               # Wait for not busy</span><br><span class="line">  testb   $0x2,%al</span><br><span class="line">  jnz     seta20.1</span><br><span class="line"></span><br><span class="line">  movb    $0xd1,%al               # 0xd1 -&gt; port 0x64</span><br><span class="line">  outb    %al,$0x64</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">  inb     $0x64,%al               # Wait for not busy</span><br><span class="line">  testb   $0x2,%al</span><br><span class="line">  jnz     seta20.2</span><br><span class="line"></span><br><span class="line">  movb    $0xdf,%al               # 0xdf -&gt; port 0x60</span><br><span class="line">  outb    %al,$0x60</span><br><span class="line"></span><br><span class="line">  # Switch from real to protected mode.  Use a bootstrap GDT that makes</span><br><span class="line">  # virtual addresses map directly to physical addresses so that the</span><br><span class="line">  # effective memory map doesn&#x27;t change during the transition.</span><br><span class="line">  lgdt    gdtdesc</span><br><span class="line">  movl    %cr0, %eax</span><br><span class="line">  orl     $CR0_PE, %eax</span><br><span class="line">  movl    %eax, %cr0</span><br><span class="line"></span><br><span class="line">//PAGEBREAK!</span><br><span class="line">  # Complete transition to 32-bit protected mode by using long jmp</span><br><span class="line">  # to reload %cs and %eip.  The segment descriptors are set up with no</span><br><span class="line">  # translation, so that the mapping is still the identity mapping.</span><br><span class="line">  ljmp    $(SEG_KCODE&lt;&lt;3), $start32</span><br><span class="line"></span><br><span class="line">.code32  # Tell assembler to generate 32-bit code now.</span><br><span class="line">start32:</span><br><span class="line">  # Set up the protected-mode data segment registers</span><br><span class="line">  movw    $(SEG_KDATA&lt;&lt;3), %ax    # Our data segment selector</span><br><span class="line">  movw    %ax, %ds                # -&gt; DS: Data Segment</span><br><span class="line">  movw    %ax, %es                # -&gt; ES: Extra Segment</span><br><span class="line">  movw    %ax, %ss                # -&gt; SS: Stack Segment</span><br><span class="line">  movw    $0, %ax                 # Zero segments not ready for use</span><br><span class="line">  movw    %ax, %fs                # -&gt; FS</span><br><span class="line">  movw    %ax, %gs                # -&gt; GS</span><br><span class="line"></span><br><span class="line">  # Set up the stack pointer and call into C.</span><br><span class="line">  movl    $start, %esp</span><br><span class="line">  call    bootmain</span><br><span class="line"></span><br><span class="line">  # If bootmain returns (it shouldn&#x27;t), trigger a Bochs</span><br><span class="line">  # breakpoint if running under Bochs, then loop.</span><br><span class="line">  movw    $0x8a00, %ax            # 0x8a00 -&gt; port 0x8a00</span><br><span class="line">  movw    %ax, %dx</span><br><span class="line">  outw    %ax, %dx</span><br><span class="line">  movw    $0x8ae0, %ax            # 0x8ae0 -&gt; port 0x8a00</span><br><span class="line">  outw    %ax, %dx</span><br><span class="line">spin:</span><br><span class="line">  jmp     spin</span><br><span class="line"></span><br><span class="line"># Bootstrap GDT</span><br><span class="line">.p2align 2                                # force 4 byte alignment</span><br><span class="line">gdt:</span><br><span class="line">  SEG_NULLASM                             # null seg</span><br><span class="line">  SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   # code seg</span><br><span class="line">  SEG_ASM(STA_W, 0x0, 0xffffffff)         # data seg</span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">  .word   (gdtdesc - gdt - 1)             # sizeof(gdt) - 1</span><br><span class="line">  .long   gdt                             # address gdt</span><br></pre></td></tr></table></figure>

<h2 id="预备"><a href="#预备" class="headerlink" title="预备"></a>预备</h2><p>BIOS模式下开启了中断，我们首先要关中断（13行），因为这时候我们并不想被中断打扰。</p>
<p>16-19行清空寄存器ax、ds、es、ss。</p>
<h2 id="开启A20-Gate"><a href="#开启A20-Gate" class="headerlink" title="开启A20 Gate"></a>开启A20 Gate</h2><p>在说明seta20.1和seta20.2做了什么之前，我们需要一些前置知识。</p>
<hr>
<p><strong>A20门与8042</strong>：</p>
<p>8086处理器拥有20位的地址总线，可以寻址最大1MB的内存，而80286的地址线扩充到了24位。8086的CS:IP寻址模式最大寻址<code>0xffff0 + 0xffff = 0x10ffef</code>，CS:IP即段加段偏移的地址表达能力超过了20位地址线的实际物理寻址能力，所以当你访问大于1M区域时会发生回绕现象，即如果你企图寻址0x100001这个地址，你实际得到的内容是地址0x00001上的内容，而80286会直接寻址对应的内存，而不是像8086回绕从0开始的0x000000以上的内存。为了保持向8086的兼容性，Intel使用了一种巧妙的方法——使用8042芯片的剩余的一个引脚的输出作为辅助判定（被称为A20 Gate），当然这是一种骇客行为，因为8042芯片本身是作为键盘控制器使用的。</p>
<p>8042是主板上的一个芯片，是键盘控制器，CPU通过与8042芯片打交道来间接控制键盘。8042芯片内有4个8位寄存器，分别是状态寄存器、输入缓冲寄存器、输出缓冲寄存器、控制寄存器，还有一个8位的CPU用于测试和控制（此CPU非计算机的中央处理器所指的CPU）。8042结构图如下：</p>
<p><img src="https://hickey-image.oss-cn-shanghai.aliyuncs.com/image/20220512235637-2022-05-12-23-56-37.png" alt="image-20220511233032988"></p>
<p>其中Control Register在上图中没有表现，又被称作Command Byte。下面的图更好的说明。</p>
<p><img src="https://hickey-image.oss-cn-shanghai.aliyuncs.com/image/20220512235646-2022-05-12-23-56-46.png" alt="image-20220512000523244"></p>
<p>8042还有3个内部端口：Input port, Output port和Test Port。Output port有System Reset和<strong>A20 Gate</strong>两个与键盘无关的重要的控制位，其它的位都是向8048芯片输出，让8048芯片参考的控制位。</p>
<p>状态寄存器是只读寄存器，CPU可以随时读取这个寄存器来获取键盘的状态。</p>
<p>输入缓冲寄存器是相对8042芯片而言的输入，可以缓冲CPU发来的命令和数据。</p>
<p>输出缓冲寄存器也是相对8042芯片而言的输出，可以缓冲键盘来的数据、响应给CPU命令的数据等供CPU读取。</p>
<p>对8042的寄存器的操作映射到两个端口上：分别是0x60和0x64端口。</p>
<p>输入缓冲寄存器的地址为0x60或0x64。当主CPU对输入缓冲寄存器地址0x64执行写操作时，写入的是系统向8042发送的控制命令，这类控制命令共有12条,主要用来控制8042的工作。当主CPU对输入缓冲寄存器地址0x60H执行写操作时，写入的是系统向键盘发送的控制命令,这类控制命令共有10条，如复位键盘、重发、回送响应、启动键盘等。</p>
<p>输出缓冲寄存器的地址为0x60。8042通过输出数据缓冲器向系统传送由键盘送来的扫描码和命令。只有当状态寄存器中的bit 1位为1时，CPU才能对输出数据缓冲器进行读取。</p>
<p>状态寄存器可以通过读0x64端口获取。</p>
<hr>
<p>理论上来说，要关闭A20门只需向8042芯片发送一个命令即可，即向端口0x64写入内容，但考虑到8042芯片的此时输入输出寄存器中可能会有内容，那么我们首先需要确保8042芯片空闲。由于关闭了中断，我们只能通过轮询来检查8042是否空闲。</p>
<p>23-26行循环读取0x64端口，并测试bit 1(从0开始)是否为0，这样做其实就是读取8042的状态寄存器的内容，8042状态寄存器bit 1为0代表8042的输入寄存器为空，可以向8042写入，否则，bit 1为1，表示输入寄存器内容不为空，8042还没有处理完输入寄存器中的内容，此时不能写入，必须等待8042处理完输入寄存器中的旧值。</p>
<p>一旦检测到8042输入寄存器空闲了，跳出循环，执行28-29。向0x64端口写入0xd1命令表示CPU准备写输出寄存器，且随后通过0x60h端口写入的字节，会被放置在上图中的输出端口中。</p>
<p>31-34行同23-26行。</p>
<p>一旦检测到8042输入寄存器空闲了，跳出循环，执行36-37。向0x60端口写入0xdf会使8042将写入到输入缓冲寄存器上的0xdf放到其输出端口上（因为28-29的设置）。0xdf即11011111意味着bit 1 为1，而输出端口各位的意义如下图：</p>
<p><img src="https://hickey-image.oss-cn-shanghai.aliyuncs.com/image/20220512235650-2022-05-12-23-56-50.png" alt="image-20220512001326640"></p>
<p>因此，这样做就是打开了A20 Gate。</p>
<h2 id="进入保护模式"><a href="#进入保护模式" class="headerlink" title="进入保护模式"></a>进入保护模式</h2><p>此时，计算机还工作在实模式下，即用<code>段地址:段偏移</code>的方式寻址。缺点就是此处的段地址真的直接对应物理地址，这样做对于多任务和安全性带来威胁。而保护模式下虽然也使用段地址和段偏移的方式，但段地址不是由cs等段寄存器直接给出，此时，段寄存器给的是一个数据结构的索引，这个数据结构称为全局描述符表（GDT），通过索引找到表中的某个表项，才得到真正的段地址。</p>
<p>因此，为了进入保护模式，我们首先需要设置全局描述符表，第42行做了这件事。GDT的每个表项即每个描述符长度为8字节（64位），如图，上下分别是高32位和低32位：</p>
<p><img src="https://hickey-image.oss-cn-shanghai.aliyuncs.com/image/20220512235654-2022-05-12-23-56-54.png" alt="img"></p>
<p>描述符中指定了 32 位的段起始地址，以及 20 位的段边界（段起始地址和段边界都不是连着给出的，从上图就可以看出，段基地址由三部分组成，段界限由两部分组成）。在实模式下，段地址并非真实的物理地址，在计算物理地址时，还要左移 4 位（乘以 16）。和实模式不同，在 32 位保护模式下，段地址是 32 位的线性地址（实打实的段基地址），如果未开启分页功能，该线性地址就是物理地址（其实，实模式寻址是<code>段地址&lt;&lt;4 + 段偏移</code>，而保护模式寻址是<code>段基地址 + 段偏移</code>）。</p>
<p>第42行将全局描述符表的信息（48位：16位长度，其实严谨的来说是长度偏移量，因为在数值上总是等于表的大小减一，和c语言中的数组下标类似；32位地址指出全局描述符表在内存中的地址）载入到GDTR（全局描述符表寄存器，48位，相应地，由16位长度和32位地址组成）。</p>
<p>80-83行涉及的全局描述符表项定义如下，GDT的第一个条目一定要为NULL（0x0000000000000000）。：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SEG_NULLASM                                             \</span></span><br><span class="line"><span class="meta">        .word 0, 0;                                             \</span></span><br><span class="line"><span class="meta">        .byte 0, 0, 0, 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The 0xC0 means the limit is in 4096-byte units (C0即11000000，表明G和D位为1)</span></span><br><span class="line"><span class="comment">// and (for executable segments) 32-bit mode. 输入的lim为32位，这里取高20位作为段界限 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEG_ASM(type,base,lim)                                  \</span></span><br><span class="line"><span class="meta">        .word (((lim) &gt;&gt; 12) &amp; 0xffff), ((base) &amp; 0xffff);      \</span></span><br><span class="line"><span class="meta">        .byte (((base) &gt;&gt; 16) &amp; 0xff), (0x90 | (type)),         \</span></span><br><span class="line"><span class="meta">                (0xC0 | (((lim) &gt;&gt; 28) &amp; 0xf)), (((base) &gt;&gt; 24) &amp; 0xff)</span></span><br></pre></td></tr></table></figure>

<p>82-83代码段和数据段的基地址都是0，<strong>段大小是4GB</strong>。</p>
<p>在设置了GDT后，我们可以正式地进入保护模式了，cr0寄存器的bit 0位被规定用来指明系统处于保护模式还是实模式。通过将cr0寄存器的bit 0位置1，我们就正式进入了保护模式。这是43-45行做的事，其中<code>CR0_PE</code>定义为<code>#define CR0_PE 0x00000001</code>。</p>
<p>还有一点事，虽然前面我们设置了GDT，但是CS和IP并没有被重新载入，CS和IP还是使用的实模式下的CS:IP（还记得吗，start的地址是CS:IP=0:0x7c00）。所以我们通过ljmp指定来改变CS和IP，前面说过，进入保护模式后，CS寄存器的意义就发生了改变了，16位CS寄存器成为了GDT的索引，具体如下：</p>
<p><img src="https://hickey-image.oss-cn-shanghai.aliyuncs.com/image/20220512235658-2022-05-12-23-56-58.png" alt="img"></p>
<p>之前设置的GDT的第1项（第0项为NULL）就是代码段，<code>#define SEG_KCODE 1</code>左移3位则TI=0，RPL=0，Index=1，表明查GDT表的第1项获取段基地址，而段偏移通过符号地址start32给出。</p>
<h2 id="进入bootmain"><a href="#进入bootmain" class="headerlink" title="进入bootmain"></a>进入bootmain</h2><p>在进入bootmain之前，我们先设置一下各数据段（ds、es、ss）的选择子，之前我们只设置了代码段的选择子。目前我们不准备使用fs、gs寄存器，于是将他们清零。这些是56-62行代码做的事情。</p>
<p>为了调用bootmain，我们先设置栈顶指针esp。基于前面的设置，此时代码段CS、栈段SS选择子指向的GDT描述符的段基地址都是0x0，而由于start是从0x7c00开始的，而x86栈向低地址增长，因此0x7c00以下的内存是可以存放栈内容的，因此将栈顶设为start的地址。</p>
<p>通过一个call指令，我们终于进入了bootmain.c，告别了汇编代码。</p>
<p>bootmain.c代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Boot loader.</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Part of the boot sector, along with bootasm.S, which calls bootmain().</span></span><br><span class="line"><span class="comment">// bootasm.S has put the processor into protected 32-bit mode.</span></span><br><span class="line"><span class="comment">// bootmain() loads an ELF kernel image from the disk starting at</span></span><br><span class="line"><span class="comment">// sector 1 and then jumps to the kernel entry routine.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;elf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;x86.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECTSIZE  512</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">readseg</span><span class="params">(uchar*, uint, uint)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bootmain</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> *<span class="title">elf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line">  <span class="type">void</span> (*entry)(<span class="type">void</span>);</span><br><span class="line">  uchar* pa;</span><br><span class="line"></span><br><span class="line">  elf = (<span class="keyword">struct</span> elfhdr*)<span class="number">0x10000</span>;  <span class="comment">// 分配内存</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read 1st page off disk</span></span><br><span class="line">  readseg((uchar*)elf, <span class="number">4096</span>, <span class="number">0</span>);	<span class="comment">// 80386页大小为4KB</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is this an ELF executable?</span></span><br><span class="line">  <span class="keyword">if</span>(elf-&gt;magic != ELF_MAGIC)</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">// let bootasm.S handle error</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Load each program segment (ignores ph flags).</span></span><br><span class="line">  ph = (<span class="keyword">struct</span> proghdr*)((uchar*)elf + elf-&gt;phoff);</span><br><span class="line">  eph = ph + elf-&gt;phnum;</span><br><span class="line">  <span class="keyword">for</span>(; ph &lt; eph; ph++)&#123;</span><br><span class="line">    pa = (uchar*)ph-&gt;paddr;</span><br><span class="line">    readseg(pa, ph-&gt;filesz, ph-&gt;off);</span><br><span class="line">    <span class="keyword">if</span>(ph-&gt;memsz &gt; ph-&gt;filesz)</span><br><span class="line">      stosb(pa + ph-&gt;filesz, <span class="number">0</span>, ph-&gt;memsz - ph-&gt;filesz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Call the entry point from the ELF header.</span></span><br><span class="line">  <span class="comment">// Does not return!</span></span><br><span class="line">  entry = (<span class="type">void</span>(*)(<span class="type">void</span>))(elf-&gt;entry);</span><br><span class="line">  entry();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">waitdisk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Wait for disk ready.  </span></span><br><span class="line">  <span class="keyword">while</span>((inb(<span class="number">0x1F7</span>) &amp; <span class="number">0xC0</span>) != <span class="number">0x40</span>)</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read a single sector at offset(disk) into dst(memory).</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">readsect</span><span class="params">(<span class="type">void</span> *dst, uint offset)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Issue command.</span></span><br><span class="line">  waitdisk();</span><br><span class="line">  outb(<span class="number">0x1F2</span>, <span class="number">1</span>);   <span class="comment">// count = 1</span></span><br><span class="line">  outb(<span class="number">0x1F3</span>, offset);</span><br><span class="line">  outb(<span class="number">0x1F4</span>, offset &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  outb(<span class="number">0x1F5</span>, offset &gt;&gt; <span class="number">16</span>);</span><br><span class="line">  outb(<span class="number">0x1F6</span>, (offset &gt;&gt; <span class="number">24</span>) | <span class="number">0xE0</span>);</span><br><span class="line">  outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);  <span class="comment">// cmd 0x20 - read sectors</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read data.</span></span><br><span class="line">  waitdisk();</span><br><span class="line">  insl(<span class="number">0x1F0</span>, dst, SECTSIZE/<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read &#x27;count&#x27; bytes at &#x27;offset&#x27; from kernel into physical address &#x27;pa&#x27;.</span></span><br><span class="line"><span class="comment">// Might copy more than asked.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">readseg</span><span class="params">(uchar* pa, uint count, uint offset)</span></span><br><span class="line">&#123;</span><br><span class="line">  uchar* epa;</span><br><span class="line"></span><br><span class="line">  epa = pa + count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Round down to sector boundary.</span></span><br><span class="line">  pa -= offset % SECTSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Translate from bytes to sectors; kernel starts at sector 1.</span></span><br><span class="line">  offset = (offset / SECTSIZE) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this is too slow, we could read lots of sectors at a time.</span></span><br><span class="line">  <span class="comment">// We&#x27;d write more to memory than asked, but it doesn&#x27;t matter --</span></span><br><span class="line">  <span class="comment">// we load in increasing order.</span></span><br><span class="line">  <span class="keyword">for</span>(; pa &lt; epa; pa += SECTSIZE, offset++)	<span class="comment">// 现在的offset的单位是扇区</span></span><br><span class="line">    readsect(pa, offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当所有的脏活累活都由bootasm.S做完之后，bootmain.c要做的工作就极为简单了：将位于磁盘扇区1位置及其后的操作系统ELF文件载入内存，然后执行此ELF文件中的操作系统入口代码。</p>
<p>此处，waitdisk和readsect使用lba28位方式读取磁盘。目前计算机还未启用分页机制，物理地址=线性地址=段基地址+段偏移，段基地址是通过选择子索引GDT得到的。</p>
<hr>
<p><strong>读写磁盘chs、lba</strong>：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jadeshu/p/11873540.html">LBA逻辑块地址 - jadeshu - 博客园 (cnblogs.com)</a></p>
<hr>
<hr>
<p><strong>ELF文件格式</strong>：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiqingwu/p/elf_format_research_01.html">ELF文件解析（一）：Segment和Section - JollyWing - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiqingwu/p/elf_explore_2.html">ELF文件解析（二）：ELF header详解 - JollyWing - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiqingwu/p/elf_explore_3.html">ELF格式探析之三：sections - JollyWing - 博客园 (cnblogs.com)</a></p>
<p>[<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-259901.htm">原创] ELF文件格式解析器 原理 + 代码-编程技术-看雪论坛-安全社区|安全招聘|bbs.pediy.com</a></p>
<hr>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>理论上来说bootmain是不会返回的，所以call指令后的代码对于一个正常的操作系统根本不会被执行，但为了实验，如果发生错误并且在Bochs（IA32模拟器）上运行操作系统代码，bootasm.S 70-76行的代码会向Bochs报告并陷入死循环。</p>
<h1 id="产生最终的引导加载器代码"><a href="#产生最终的引导加载器代码" class="headerlink" title="产生最终的引导加载器代码"></a>产生最终的引导加载器代码</h1><p>引导加载器要被放在磁盘的0扇区，一个扇区大小是512字节，规定引导加载器代码最后2字节必须是魔数0xAA55，因此引导加载器代码最长510字节，不足补’\0’。</p>
<p>下面的perl代码将把bootasm.S和bootmain.c编译链接后生成的bootblock.o文件补’\0’和魔数，使之满足引导加载器最终代码的规定：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span>(SIG, $ARGV[<span class="number">0</span>]) || <span class="keyword">die</span> <span class="string">&quot;open $ARGV[0]: $!&quot;</span>;</span><br><span class="line"></span><br><span class="line">$n = <span class="keyword">sysread</span>(SIG, $buf, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($n &gt; <span class="number">510</span>)&#123;</span><br><span class="line">  <span class="keyword">print</span> STDERR <span class="string">&quot;boot block too large: $n bytes (max 510)\n&quot;</span>;</span><br><span class="line">  <span class="keyword">exit</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> STDERR <span class="string">&quot;boot block is $n bytes (max 510)\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">$buf .= <span class="string">&quot;\0&quot;</span> <span class="keyword">x</span> (<span class="number">510</span>-$n);</span><br><span class="line">$buf .= <span class="string">&quot;\x55\xAA&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span>(SIG, <span class="string">&quot;&gt;$ARGV[0]&quot;</span>) || <span class="keyword">die</span> <span class="string">&quot;open &gt;$ARGV[0]: $!&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> SIG $buf;</span><br><span class="line"><span class="keyword">close</span> SIG;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/tree/2ae8392a5c203a7b1bc5b8bff5eabc8b5eab8972">mit-pdos/xv6-riscv at 2ae8392a5c203a7b1bc5b8bff5eabc8b5eab8972 (github.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chuganghong/p/15412601.html">写操作系统之开发引导扇区 - 东小夫 - 博客园 (cnblogs.com)</a></li>
<li>《微机接口与应用》王正洪 清华大学出版社.</li>
<li><a target="_blank" rel="noopener" href="https://docs.huihoo.com/gnu_linux/own_os/driver-keyboard_2.htm">driver-keyboard</a></li>
<li><a target="_blank" rel="noopener" href="https://stanislavs.org/helppc/8042.html">8042 (stanislavs.org)</a></li>
<li>《程序员的自我修养》 俞甲子 电子工业出版社.</li>
</ol>
</blockquote>
</div></div><div class="post-main post-comment"><div id="disqus_thread"></div><script type="text/javascript">
var disqus_shortname = 'hickey-1';
var disqus_identifier = '2022/05/11/从XV6看操作系统启动、引导加载器/';
var disqus_title = '从XV6看操作系统启动、引导加载器';
var disqus_url = 'http://hickey.ltd/2022/05/11/%E4%BB%8EXV6%E7%9C%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E3%80%81%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E5%99%A8/';
(function() {
   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
   dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a target="_blank" rel="noopener" href="http://disqus.com" class="dsq-brlink">Blog comments powered by <span class="logo-disqus">Disqus</span></a></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/font-awesome/5.15.3/css/all.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/lato-font/3.0.0/css/lato-font.min.css"><link rel="stylesheet" type="text/css" href="/css/number_title.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcdn.net/ajax/libs/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>